{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LangTorch","text":""},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"guides/t/","title":"1. Text Multiplication Guide","text":""},{"location":"guides/t/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"guides/t/#1-basics","title":"1. Basics:","text":""},{"location":"guides/t/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialised in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a sepcial f-string-like sytnax which can parse most Text\u2019s from a signle string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"guides/t/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"guides/t/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"guides/t/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"guides/t/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <p><code>python  Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))</code></p> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"guides/t/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"guides/t/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"guides/t/#4-additional-points","title":"4. Additional Points:","text":"<ul> <li> <p>The <code>Text</code> class has a a special value <code>Text.identity</code>: an empty string with no key. This value is characterised by being it being the identity element of multiplication and  <code>Text.identity == 1</code> is defined to be true to make that connection, as:</p> <p><code>python some_text * 1 == some_text * Text.identity</code></p> </li> </ul>"},{"location":"reference/t/","title":"1. Text Multiplication Guide","text":""},{"location":"reference/t/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"reference/t/#1-basics","title":"1. Basics:","text":""},{"location":"reference/t/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialised in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a sepcial f-string-like sytnax which can parse most Text\u2019s from a signle string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"reference/t/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"reference/t/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"reference/t/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"reference/t/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <p><code>python  Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))</code></p> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"reference/t/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"reference/t/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"reference/t/#4-additional-points","title":"4. Additional Points:","text":"<ul> <li> <p>The <code>Text</code> class has a a special value <code>Text.identity</code>: an empty string with no key. This value is characterised by being it being the identity element of multiplication and  <code>Text.identity == 1</code> is defined to be true to make that connection, as:</p> <p><code>python some_text * 1 == some_text * Text.identity</code></p> </li> </ul>"}]}