{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>LangTorch is a framework that simplifies development of complex language model applications by leveraging familiar PyTorch concepts.</p> <p>While existing frameworks focus on connecting language models to other services, LangTorch aims to change the way you approach building LLM applications by introducing a unified framework for working with texts, chats, markup languages, tokens, embeddings, LLM calls and functions with seamless parallelization working with OpenAI APIs and PyTorch models. The result? Less code, faster development and more intricate LLM applications.</p>"},{"location":"#the-langtorch-framework","title":"The LangTorch Framework","text":"<p>Instead of providing wrapper classes for users to memorize, LangTorch introduces key objects that while governed by few simple rules, enable all kinds of text formatting and transformations. This lets developers think about what they want to build, instead of how the classes were named. LangTorch components subclass their numerical PyTorch counterparts, which lets users apply their existing coding skills to building novel LLM app architectures. The design of the package is geared towards users that want to test and create new architectures or methods that increase the utility of LLMs, rather than streamlining the most common chat and RAG architectures.</p> <p>Note the package is early in its development and some features may be unstable or unfinished!  Use for research rather than production purposes</p> TextTensors        inherits functionalities from <code>torch.Tensor</code>, but holds structured text as entries. TextTensors allow us to structure text information geometrically and dynamically inject this data into LLM calls.The utility of Tensors, as used in Torch, relies on their ability to calculate simultaneously products of several weights. The corresponding feature in TextTorch allows several prompts to be formatted on several inputs, by defining the product of <code>text1</code> and <code>text2</code> similarly to <code>text1.format(text2)</code>.       <pre><code>prompt_templates = TextTensor(\n                   [[\"{name}: {greeting}!\"],  \n                    [\"{greeting}, {name}!\"]]\n                   )\n\nx = prompt_templates * TextTensor(\n                    {\"greeting\": \"Hello\", \"name\": \"Alice\"}\n                    ) \nprint(x)\n</code></pre> Output:<pre><code>[[Alice: Hello!]\n [Hello, Alice!]]\n</code></pre> <pre><code>from langtorch import TextModule\n\nparallel_tasks= TextModule(\"Calculate this equation:\\n\")\n\nprint(parallel_tasks())\n</code></pre> Supporting PyTorch utilities   LangTorch implements textual versions of many PyTorch utilities. TextTensors can be accessed, reshaped, squeezed, unsqueezed and so on just like torch tensors. Moreover, using regular torch functions they can be summed (text join), stacked, concatenated, used in tensor datasets, and even traced with autograd. In the near future this ability will be used in automatic prompt optimization given a text description of our \"loss function\".  TODO code examples Text task dataset and loaderSomething else (reshape i sp\u00f3\u0142ka?)Something else 2 (autograd?) <p> <pre><code>from torch.utils.data import DataLoader, TensorDataset\n\n# Define the dataset\ninput_data = (User([f\"Is {word} positive?\" for word in [\"love\", \"chair\", \"non-negative\"]]) * Assistant([\"Yes\", \"No\", \"Yes\"])).requires_grad_()\ntarget_data = TextTensor(['Yes', \"No\", \"No\"])\n\n# Wrap the data in a TensorDataset and then create a DataLoader\ndataset = TensorDataset(input_data, target_data)\ndataloader = DataLoader(dataset, batch_size=16)  # Adjust the batch size as needed\n\n# Define your TextModule\ntext_module = TextModule(\"{*}\")  # Initialize your TextModule here\n\n# Loop over the DataLoader\nfor i, (inputs, targets) in enumerate(dataloader):\n    # Pass the batch through the TextModule\n    outputs = text_module(inputs)\n</code></pre> </p> <p> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> </p> <p> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> s </p> <pre><code># TODO\n</code></pre> Richer text representations    Every text entry in LangTorch has a set structure, such that they can be constructed from and formatted into any markup language. This unified structure allows for a systematic treatment of diverse objects like chat histories, chunked documents, document stores, dictionaries, text meta-data, extracted named entities and code.  This structure is expanded in <code>TextTensors</code> giving them the ability  hold multiple representations of the same text  and automatically switch between acting as strings when printed, as embeddings when inputted into <code>torch.cosine_similarity</code> and as tokens when passed to a local LLM.       Embeddings   Will totally write this, probably, maybe      <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre>"},{"location":"#textmodule","title":"TextModules","text":"are the compositional building blocks. A subclass of <code>torch.nn.Module</code>, <code>TextModules</code> are reusable \"layers\", whose weights are <code>TextTensors</code>, and which instead of an activation function can include the activation of an LLM call on the dynamically created text inputs.Instead of many clunky retrievers, chains, chats or agent, all can be defined as TextModules with different forward calls. These can then be easily included as submodules in complex modules that in the forward pass perform any parts of common architectures, like operations on embeddings, retrieval, parallel LLM API calls, batched local LLM inference, actions and so on."},{"location":"#dive-in-and-get-started","title":"Dive In and Get Started","text":"<p>Install LangTorch with: <pre><code>pip install langtorch\n</code></pre></p> <p>Next steps:</p> <ul> <li> <p> Quick-Start Tutorial</p> <p>Get building with LangTorch in 5 minutes</p> <p> Getting started</p> </li> <li> <p> Reference</p> <p>Learn how to use Text objects, TextTensors, TextModules, Activations  and Torch functions with LangTorch</p> <p> Reference.</p> </li> <li> <p> Discord</p> <p>Join the Discord community to for fast bug fixes and support!</p> <p> Discord</p> </li> <li> <p> Github</p> <p> Star </p> <p> GitHub Repo</p> </li> </ul> <p>Join us in improving the LLM application dev experience!</p> <p>Contact: contact@langtorch.org</p>"},{"location":"Todo/","title":"Todo","text":"<ul> <li>[ ] Dodaj jako pierwsze feature text being structured. Explain it in terms of defining operations on structured text in structured text.</li> <li>[ ] sekcja integrations: x pytorch x transformers x openai maybe</li> <li>[ ] Przypisa\u0107 intro z klas na na features (semantic algebra, )</li> <li>[ ] goals of the package: create a </li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide: Dive into LangTorch","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>LangTorch works with Python 3.8 or higher. To install LangTorch using pip:</p> <pre><code>pip install langtorch\n</code></pre>"},{"location":"quickstart/#getting-tensor-text-data","title":"Getting tensor text data","text":"<p>TextTensors in LangTorch are designed to simplify the handling of textual data. They inherit from PyTorch's <code>torch.Tensor</code> but are specialized to hold textual data. </p> <pre><code>from langtorch import TextTensor\n\n# Initialize with a list of strings\ntt = TextTensor([[\"Hello, world!\"], [\"How are you?\"]])\n</code></pre>"},{"location":"quickstart/#prompt-templating-with-texttensor-operations","title":"Prompt templating with TextTensor operations","text":"<p>Addition concatenates the text, while multiplication performs template formatting:</p> <pre><code># Concatenation\nnew_tt = tt + \" Have a great day!\"\n\n# Template formatting\nformatted_tt = TextTensor([\"{greeting}, {name}!\"]) * TextTensor({\"greeting\": \"Hello\", \"name\": \"Alice\"})\n</code></pre>"},{"location":"quickstart/#performing-a-task-with-textmodules","title":"Performing a task with TextModules","text":"<p>TextModules like <code>nn.Module</code> implement a forward method that works on (text) tensors. By default they can be initialized by passing a TextTensor of prompts, that in the forward pass will be formatted using the input TextTensor (just like in the example above).  </p> <p>However, as with nn.Modules, to achieve interesting behavior the multiplied tensors need to be passed to an \"activation function,\" which in this context is an LLM call on the formatted prompts.</p> <pre><code>from langtorch import TextModule, OpenAI\n\nllm = OpenAI(\"gpt4\", T = 0.) # Pass any API kwargs here to customize the call \n# Initialize TextModule with the activation\ntext_mod = TextModule(\"Translate this text: {}\", activation=llm)\n</code></pre>"},{"location":"quickstart/#parallel-and-chained-calls-with-textmodules","title":"Parallel and Chained calls with TextModules","text":"<p>LangTorch uses a custom implementation to speed up and cache api calls, that by default run in parallel for all TextTensor entries passed to an LLM activation. As such, running calls in parallel is done automatically if either multiple prompts, multiple input values or both are passed to an LLM. </p> <p>To create complex chains, you may, as in torch, define a module subclass that adds custom behavior or combines many submodules. The simplest way to chain TextModule is to directly use <code>torch.nn.Sequential</code>.</p> <pre><code>import torch\n#Create a custom TextModule\nclass UsefulTextModule(TextModule):\n    def forward(self, input):\n        self.activation(input + \" Please give me the wrong answer.\")\n\n\n# Create a pipeline\npipeline = torch.nn.Sequential(\n    TextModule(\"Translate this text to English: {}\"),\n    TextModule(\"Summarize the translated text: {}\", activation=SomeSummarizationLLM)\n)\n</code></pre> <p>Execute the pipeline by simply passing your TextTensor:</p> <pre><code>output = pipeline(tt)\n</code></pre>"},{"location":"quickstart/#retriever","title":"Retriever","text":"<ul> <li>Cosine Similarities: LangTorch provides a <code>CosineSimilarity</code> class to compute similarities between TextTensors.</li> </ul> <pre><code>from langtorch.tt import CosineSimilarity\n\ncos = CosineSimilarity()\nsimilarities = cos(tt, TextTensor([\"1\", \"0\", \"No\", \"Yes\"]))\n</code></pre> <p>TODO retriever</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Congratulations, you've completed the Quickstart Guide! For a deeper understanding, explore our Conceptual Guides and API Documentation.</p> <p>Feel free to contribute; check our contribution guidelines.</p> <p>Happy LangTorching! \ud83c\udf89</p>"},{"location":"guides/2/","title":"Using different TextTensors","text":""},{"location":"guides/3/","title":"Chaining with TextModules","text":""},{"location":"guides/4/","title":"Advanced applications","text":""},{"location":"guides/text/","title":"1. Text Multiplication Guide","text":""},{"location":"guides/text/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"guides/text/#1-basics","title":"1. Basics:","text":""},{"location":"guides/text/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialized in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a special f-string-like sytnax which can parse most Text\u2019s from a single string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"guides/text/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"guides/text/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"guides/text/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"guides/text/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <pre><code> Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))\n</code></pre> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"guides/text/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"guides/text/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"guides/text/#4-additional-points","title":"4. Additional Points:","text":""},{"location":"guides/langchain_comparison/translation/","title":"Translation","text":"LangChain LangTorch PromptTemplate.from_template(prompt) TextTensor(prompt) ChatPromptTemplate.from_template([(role, message), ...]) RunnablePassthrough() TextModule(\"\") StrOutputParser # Not needed itemgetter(key)"},{"location":"reference/langtorch/","title":"Index","text":"<p>LangTorch implements many of the same utility functions one can use in Torch. To streamline usage, these are also automatically invoked if one passes TextTensor inputs to the analogous torch function. </p> <p>Functions, that take in TextTensors and output TextTensors (note, functions like <code>reshape</code> are also TextTensor methods):</p> Operation Description stack Concatenates a sequence of TextTensors along a new dimension. cat Concatenates the given sequence of <code>seq</code> TextTensors in the given dimension. reshape Returns a TextTensor with the same data and number of elements as the input, but with the specified shape. squeeze Returns a TextTensor with all the dimensions of input of size 1 removed. unsqueeze Returns a TextTensor with a dimension of size one inserted at the specified position. swapaxes Swaps two axes of the TextTensor."},{"location":"reference/langtorch/#semantic-algebra-vs-tensor-algebra","title":"Semantic algebra vs Tensor algebra","text":"<p>One of the benefits of representing information geometrically in tensors is that we can have meaningful dimensions, that differentiate e.g. different answers to the same query. In such cases, often we wish to perform some action along this dimension. For the dimension of different answers we may want to synthesize the answers into one better answer, or pick out the best one. </p> <p>What LangTorch proposes is that we may think of such operations as taking the (semantic) mean and max value along that dimension. In another use cases the mean may be used to average the embeddings along a dimension. To enable both, the following function operate as numerical operations on embeddings if imported from torch, and as \"semantic\" functions that call an LLM to perform the analogous operation on texts: </p> Method Description torch.mean langtorch.mean torch.max langtorch.max unsqueeze swapaxes"},{"location":"reference/tensors/texttensor/","title":"TextTensor","text":"<p>A <code>TextTensor</code> is a multi-dimensional matrix containing elements of structured text data, each represented as a <code>Text</code> object  of structured text.</p>"},{"location":"reference/tensors/texttensor/#initializing-and-basic-operations","title":"Initializing and Basic Operations","text":"<p>A <code>TextTensor</code> can be constructed from Python lists or sequences of string-like inputs. Every entry is transformed into a Text object, so each entry must satisfy one of its many possible input formats, which can include:</p> <ul> <li>Strings</li> <li>Tuples of the form  representing text keys and values</li> <li>Dictionaries of correctly ordered keys and values</li> <li>Sequences of any of the above</li> </ul>"},{"location":"reference/tensors/texttensor/#construction","title":"Construction","text":"<p>You can construct a <code>TextTensor</code>, similar to <code>torch.tensor</code>, where the input sequence can be shapes into  nested lists or a numpy array:</p> <pre><code>from langtorch import TextTensor\n\n# 0-d TextTensor\n\n# 1-d TextTensor\n\n# 2-d TextTensor, and so on\nTextTensor([[\"Hello, world!\"], [\"How are you?\"]])\n\n# With complex text entries\n\n\n# Text\n\nTextTensor([{\"greeting\": \"Hello\", \"name\": \"Alice\"}])\n</code></pre> <p>TextTensors can be created with familiar operations: <pre><code># A tensor of empty strings\nlangtorch.zeros(shape)\nlangtorch.zeros_like(tensor)\n\n# A tensor with all \n</code></pre></p> <p>Note</p> <p>TextTensors almost never get initialised from torch Tensors</p>"},{"location":"reference/tensors/texttensor/#indexing-and-slicing","title":"Indexing and Slicing","text":"<p>Access and modify the contents of a <code>TextTensor</code> using Python's indexing and slicing notation:</p> <pre><code>tt = TextTensor([[\"Hello\", \"World\"], [\"LangTorch\", \"Framework\"]])\nprint(tt[0][1])  # Outputs: \"World\"\ntt[1][0] = \"Welcome to\"\nprint(tt)  # Outputs: TextTensor([[\"Hello\", \"World\"], [\"Welcome to\", \"Framework\"]])\n</code></pre>"},{"location":"reference/tensors/texttensor/#item-extraction","title":"Item Extraction","text":"<p>Extract a single <code>Text</code> object from a <code>TextTensor</code>:</p> <pre><code>tt = TextTensor([[\"Hello\"]])\nsingle_text = tt.item()\nprint(single_text)  # Outputs: \"Hello\"\n</code></pre> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.set_key","title":"<code>set_key(keys=None, inplace=False)</code>","text":""},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.item","title":"<code>item()</code>","text":""},{"location":"reference/tensors/texttensor/#key-assignment","title":"Key Assignment","text":"<p>Explicitly assign or change keys in a <code>TextTensor</code> using the <code>set_key()</code> method:</p> <pre><code>tt = TextTensor([\"This is a sentence.\"])\ntt.set_key(\"sentence\")\n</code></pre> <p>For comprehensive details on creating and manipulating <code>TextTensors</code>, refer to the LangTorch documentation on <code>TextTensor</code> operations.</p> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.set_key","title":"<code>set_key(keys=None, inplace=False)</code>","text":""},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.item","title":"<code>item()</code>","text":""},{"location":"reference/tensors/texttensor/#warnings-and-notes","title":"Warnings and Notes","text":"<ul> <li>Operations involving keys require accurate matching between the template and data.</li> <li><code>TextTensors</code> support a variety of operations for modifying and generating new <code>TextTensors</code>.</li> <li>For advanced text processing with LLMs, utilize <code>TextModule</code> along with <code>TextTensors</code>.</li> </ul> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.split","title":"<code>split(sep, dim=0)</code>","text":"<p>Return a new TextTensor, with an additional first dimension to split everything using sep as the delimiter.</p> <p>sep     The delimiter according which to split the bytearray.     None (the default value) means split on ASCII whitespace characters     (space, tab, return, newline, formfeed, vertical tab).</p>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.apply","title":"<code>apply(func)</code>","text":"<p>Applies a function to each entry of self.content.</p>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.backward","title":"<code>backward(tensors, grad_tensors=None, retain_graph=None, create_graph=False, grad_variables=None, inputs=None)</code>","text":"<p>See. docs</p>"},{"location":"reference/texts/text/","title":"Text","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#indexing","title":"Indexing","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre> <p>DESC</p> <p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> <ul> <li> <code>content</code>         \u2013          <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> </li> <li> <code>language</code>         \u2013          <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> </li> <li> <code>allowed_keys</code>         \u2013          <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> </li> </ul> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#langtorch.texts.Text.content","title":"<code>content</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.iloc","title":"<code>iloc</code>  <code>property</code>","text":"<p>Index-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Key-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.keys","title":"<code>keys()</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.values","title":"<code>values()</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.items","title":"<code>items()</code>","text":"<p>Retrieves key-value pairs from the Text object, allowing for structured data extraction and further processing.</p> <p>Returns:</p> <ul> <li> <code>List[Tuple[str, Union[str, Tuple[...]]]]</code>         \u2013          <p>A list of key-value pairs representing the Text's content.</p> </li> </ul>"},{"location":"reference/texts/text/#changing-keys","title":"Changing keys","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre> <p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#langtorch.texts.Text.set_key","title":"<code>set_key(key, inplace=False)</code>","text":"<p>Override keys for the textual entries, used for restructuring the content. Useful for substituting the key right before passing TextTensor to a Module.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key or keys to apply</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.add_key","title":"<code>add_key(key, inplace=False)</code>","text":"<p>Add a top-level  key, placing the items of the original as a value under the new key. Useful for working with nested keys like in Chat prompts.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key to add</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.iloc","title":"<code>iloc</code>  <code>property</code>","text":"<p>Index-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Key-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.__new__","title":"<code>__new__(*substrings, parse='langtorch-f-string', language='str', **named_substrings)</code>","text":"<p>Construct a new Text instance. Allows for various input formats.</p> <p>Parameters:</p> Name Type Description Default <code>*substrings</code> <code>Union[str,Tuple[str, str], List[str]</code> <p>Flexible input data. Can be a parsable string, string sequences, key-value pairs, dicts...                     If None is passed, it will be replaced with a Text instance with empty content.</p> <code>()</code> <code>parse</code> <code>Union[bool, str]</code> <p>Disable or specify a parsing langauge the input content is written.                         The default behavior is splits strings with an f-string-like syntax.                         You can pass a name of a markup language to parse it with pandoc.                         Set to False to disable parsing.</p> <code>'langtorch-f-string'</code> <code>language</code> <code>str</code> <p>The language that the content should be translated to when casting to string.</p> <code>'str'</code> <code>**named_substrings</code> <code>str</code> <p>Additional named textual data entries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Text</code> <p>A structured textual instance.</p> <p>Raises:</p> Type Description <code>ParseException</code> <p>If automatic parsing fails. Consider disabling parsing if this occurs.</p> <code>ValueError</code> <p>When an unsupported input format is provided e.g. a TextTensor is passed.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.add_key","title":"<code>add_key(key, inplace=False)</code>","text":"<p>Add a top-level  key, placing the items of the original as a value under the new key. Useful for working with nested keys like in Chat prompts.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key to add</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_api_responses","title":"<code>from_api_responses(*messages, **kwargs)</code>  <code>classmethod</code>","text":"<p>Text from a list of dicts of OpenAI style API responses</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_messages","title":"<code>from_messages(*messages, **kwargs)</code>  <code>classmethod</code>","text":"<p>Text from a list of dicts with keys 'role' and 'content'</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_pandoc_json","title":"<code>from_pandoc_json(ast_json)</code>  <code>classmethod</code>","text":"<p>Creates a Text object from a Pandoc AST JSON string.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.items","title":"<code>items()</code>","text":"<p>Retrieves key-value pairs from the Text object, allowing for structured data extraction and further processing.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, Union[str, Tuple[...]]]]</code> <p>A list of key-value pairs representing the Text's content.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.keyed_print","title":"<code>keyed_print()</code>","text":"<p>Prints the Text instance with keys aligned over their corresponding values.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.set_key","title":"<code>set_key(key, inplace=False)</code>","text":"<p>Override keys for the textual entries, used for restructuring the content. Useful for substituting the key right before passing TextTensor to a Module.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key or keys to apply</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.str_formatter","title":"<code>str_formatter(instance, language='str')</code>  <code>classmethod</code>","text":"<p>Formats the human-readable string of a Text instance. Subclasses of Text can reimplement this method!</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Text</code> <p>An instance of the Text class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the instance.</p>"},{"location":"reference/tt/textmodule/","title":"TextModule","text":""}]}