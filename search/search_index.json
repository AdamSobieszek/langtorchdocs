{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>LangTorch is a framework that simplifies development of complex language model applications by leveraging familiar PyTorch concepts.</p> <p>While existing frameworks focus on connecting language models to other services, LangTorch aims to change the way you approach building LLM applications by introducing a unified framework for working with texts, chats, markup languages, tokens, embeddings and code interpreters with seamless parallelization and PyTorch integration. The result? Less code, faster development and more intricate LLM applications.</p>"},{"location":"#the-langtorch-framework","title":"The LangTorch Framework","text":"<p>Instead of providing wrapper classes for users to memorize, LangTorch introduces objects that simple rules that enable all kinds of text transformations and formatting. This lets developers think about what they want to build, instead of how the classes were named. </p> <p>LangTorch components subclass their numerical PyTorch counterparts, which lets users apply their existing coding skills to building novel LLM app architectures.</p> <p>Where holding numbtorch.Tensors can be a simple rules for\u00a0<code>TextTensor</code>\u00a0operations like addition and multiplication, that in turn enable all kinds of text transformations and formatting. This lets developers think about what they want to build, instead of how the classes were named. LangTorch components subclass their numerical PyTorch counterparts, which lets users apply their existing coding skills to building novel LLM app architectures.</p> <p>For example creating a prompt template and filling its values can both be done with just TextTensors, which can be multiplied to transform texts with values of other texts:</p> <p>If you have used PyTorch you can use this knowledge when writting LangTorch where prom</p> <p>For example creating a prompt template and filling its values can both be done with just TextTensors, which can be multiplied to transform texts with values of other texts:</p> <p>If you have used PyTorch you can use this knowledge when writting LangTorch where prompt engineering, templating and LLM calls all work when used with torch constructs like <code>nn.Sequential</code>. Here is a complete example LangTorch module, that can be executed in parallel on any text input, while preserving shape and maintaining a computational graph for a backward pass. </p> <p>The package is in early preview, some features may be unstable or unfinished!</p> TextTensors   inheriting functionalities from <code>torch.Tensor</code>, but holding as entries the structured text. TextTensors allow us to structure text information geometrically, as well as manage multi-repres the same text data it in multiple forms (automatically acting as texts when printed, as embeddings when calculating cosine similarity and as tokens when passed to a local LLM).         <pre><code>prompt_templates = TextTensor(\n                   [[\"{name}: {greeting}!\"],  \n                    [\"{greeting}, {name}!\"]]\n                   )\n\nx = prompt_templates * TextTensor(\n                    {\"greeting\": \"Hello\", \"name\": \"Alice\"}\n                    ) \nprint(x)\n</code></pre> Output:<pre><code>[[Alice: Hello!]\n [Hello, Alice!]]\n</code></pre> <pre><code>from langtorch import TextModule\n\nparallel_tasks= TextModule(\"Calculate this equation:\\n\")\n\nprint(parallel_tasks())\n</code></pre> Richer text representations    Every TextTensor can store  Every text entry in LangTorch is structured, which allows texts to also represent completion dictionaries and to be formatted to and constructed from any markup language.     that can effectible represent and manipulate prompt templates, chat histories, document stores, dictionaries, markup languages and code.         <pre><code>\n</code></pre> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> Embeddings    LangTorch starts by introducing structured *      Seemless torch integration    Each retriever, chain, chat or agent, can be implemented in LangTorch using PyTorch design patterns, such as classes with a forward method, that integrate both tensor data (e.g. embeddings) and textual data (e.g. prompt templates).       <pre><code>from torch.utils.data import DataLoader, TensorDataset\n\n# Define the dataset\ninput_data = (User([f\"Is {word} positive?\" for word in [\"love\", \"chair\", \"non-negative\"]]) * Assistant([\"Yes\", \"No\", \"Yes\"])).requires_grad_()\ntarget_data = TextTensor(['Yes', \"No\", \"No\"]).requires_grad_()\n\n# Wrap the data in a TensorDataset and then create a DataLoader\ndataset = TensorDataset(input_data, target_data)\ndataloader = DataLoader(dataset, batch_size=1)  # Adjust the batch size as needed\n\n# Define your TextModule\ntext_module = TextModule(\"{*}\")  # Initialize your TextModule here\n\n# Loop over the DataLoader\nfor i, (inputs, targets) in enumerate(dataloader):\n    # Pass the batch through the TextModule\n    outputs = text_module(inputs)\n</code></pre>"},{"location":"#textmodule","title":"TextModules","text":"are the compositional building blocks. A subclass of <code>torch.nn.Module</code>, TextModules can perform all operations you may need in an LLM chain e.g. formatting, parallel LLM api calls, batched local LLM inference, embeddings, information retrieval and so on."},{"location":"#and-more","title":"And more","text":"Tab with a really long title 1Tab with a really long title 2Tab with a really long title 3 <p> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> </p> <p> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> </p> <p> <pre><code>import torch.CosineSimilarity\n\ntensor1 =[[\"Yes\"], [\"No\"]],\ntensor 2 = [\"1\", \"0\", \"Nay\", \"Si\"]\n\ntorch.CosineSimilarity(tensor1,tensor)\n</code></pre> s </p> <ul> <li>Prompt Optimization is for the first time enabled directly with autograd. LangTorch operations save a computational graph that can be traversed backward to update gradient text values or dynamically undo and repeat calls. With a dataset of examples such gradient text values can inform and optimizer on how it should update the prompts in the chain.</li> </ul> <p>As <code>TextModules</code> operate on tensor data, all operations are easily parallelizable and integrate seamlessly with PyTorch, Transformers Models and APIs. Chaining TextModules offers both low-level control and a higher level of architectural abstraction.</p> <ul> <li>Caching Results and Maintaining Context: When running your LangTorch app you can use a persistent context. This let's you cache the results of LLM calls and store all TextTensors and pending API requests in a yaml session file. This saves a lot of costs, allows the state to persist between runs, makes apps robust to crushes and creates a persistent context that can be accessed from anywhere in the code to inject content from your file system.</li> </ul>"},{"location":"#dive-in-and-get-started","title":"Dive In and Get Started","text":"<p>Install LangTorch with: <pre><code>pip install langtorch\n</code></pre></p> <p>Next steps:</p> <ul> <li> <p> Quick-Start Tutorial</p> <p>Get building with LangTorch in 5 minutes</p> <p> Getting started</p> </li> <li> <p> Reference</p> <p>Learn how to use Text objects, TextTensors, TextModules, Activations  and Torch functions with LangTorch</p> <p> Reference.</p> </li> <li> <p> Discord</p> <p>Join the Discord community to for fast bug fixes and support!</p> <p> Discord</p> </li> <li> <p> Github</p> <p> Star </p> <p> GitHub Repo</p> </li> </ul> <p>Join us in improving the LLM application dev experience. Welcome to LangTorch!</p>"},{"location":"Todo/","title":"Todo","text":"<ul> <li>[ ] Dodaj jako pierwsze feature text being structured. Explain it in terms of defining operations on structured text in structured text.</li> <li>[ ] sekcja integrations: x pytorch x transformers x openai maybe</li> <li>[ ] Przypisa\u0107 intro z klas na na features (semantic algebra, )</li> <li>[ ] goals of the package: create a </li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide: Dive into LangTorch","text":"<p>This Guide shows how to quickly start building with LangTorch. LangTorch works with:</p> <ul> <li>Python 3.8 or higher</li> <li>PyTorch 2.0.0 or higher</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install LangTorch using pip:</p> <pre><code>pip install langtorch\n</code></pre>"},{"location":"quickstart/#starting-a-project","title":"Starting a project","text":""},{"location":"quickstart/#texttensors","title":"TextTensors","text":"<p>TextTensors in LangTorch are designed to simplify the handling of textual data. They inherit from PyTorch's <code>torch.Tensor</code> but are specialized to hold textual data. </p>"},{"location":"quickstart/#creating-a-texttensor","title":"Creating a TextTensor","text":"<pre><code>from langtorch import TextTensor\n\n# Initialize with a list of strings\ntt = TextTensor([[\"Hello, world!\"], [\"How are you?\"]])\n</code></pre>"},{"location":"quickstart/#texttensor-operations","title":"TextTensor Operations","text":"<p>Addition concatenates the text, while multiplication performs template formatting:</p> <pre><code># Concatenation\nnew_tt = tt + \" Have a great day!\"\n\n# Template formatting\nformatted_tt = TextTensor([\"{greeting}, {name}!\"]) * TextTensor({\"greeting\": \"Hello\", \"name\": \"Alice\"})\n</code></pre>"},{"location":"quickstart/#text-keys","title":"Text Keys","text":"<p>You can explicitly assign or change keys in a TextTensor using the <code>set_key()</code> method:</p> <pre><code># Assign new keys\ntt_new_keys = tt.set_key(\"new_key\")\n</code></pre>"},{"location":"quickstart/#text-the-atomic-unit-of-texttensor","title":"Text: The Atomic Unit of TextTensor","text":"<p>LangTorch introduces a <code>Text</code> class that acts like an ordered dictionary but with the functionality of a string. You can initialize it with key-value pairs and perform operations like regular strings.</p> <pre><code>from langtorch import Text\n\n# Create a Text object\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\n</code></pre> <p>You can use the <code>Text</code> class to create complex TextTensors, and then apply the <code>set_key()</code> function to change keys if needed.</p>"},{"location":"quickstart/#textmodules-the-operators","title":"TextModules: The Operators","text":"<p>TextModules are akin to PyTorch's <code>nn.Module</code> but are customized to operate on TextTensors. They multiply the input TextTensor with internal content and pass it to an \"activation function,\" which in this context is an LLM call.</p> <pre><code>from langtorch import TextModule, ChatGPT\n\nllm = ChatGPT(\"gpt4\")\n# Initialize a TextModule\ntext_mod = TextModule(\"Translate this text: {}\", activation=llm)\n</code></pre>"},{"location":"quickstart/#chaining-textmodules","title":"Chaining TextModules","text":"<p>LangTorch enables you to create complex pipelines, similar to how you'd use <code>nn.Sequential</code> in PyTorch.</p> <pre><code>import torch\n\n# Create a pipeline\npipeline = torch.nn.Sequential(\n    TextModule(\"Translate this text: {}\"),\n    TextModule(\"Summarize the translated text: {}\", activation=SomeSummarizationLLM)\n)\n</code></pre>"},{"location":"quickstart/#running-your-pipeline","title":"Running Your Pipeline","text":"<p>Execute the pipeline by simply passing your TextTensor:</p> <pre><code>output = pipeline(tt)\n</code></pre>"},{"location":"quickstart/#advanced-tips","title":"Advanced Tips","text":"<ul> <li>Cosine Similarities: LangTorch provides a <code>CosineSimilarity</code> class to compute similarities between TextTensors.</li> </ul> <pre><code>from langtorch.tt import CosineSimilarity\n\ncos = CosineSimilarity()\nsimilarities = cos(tt, TextTensor([\"1\", \"0\", \"No\", \"Yes\"]))\n</code></pre> <ul> <li> <p>Temperature Settings: For creative tasks, set a high temperature (e.g., 1.2), and for more analytical tasks, a lower temperature (e.g., 0.5).</p> </li> <li> <p>Key Management: Always make sure the TextTensors have the correct keys that the TextModule templates expect. Utilize the <code>set_key()</code> method and the <code>key</code> argument in <code>TextModule</code> for this.</p> </li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Congratulations, you've completed the Quickstart Guide! For a deeper understanding, explore our Conceptual Guides and API Documentation.</p> <p>Feel free to contribute; check our contribution guidelines.</p> <p>Happy LangTorching! \ud83c\udf89</p>"},{"location":"guides/2/","title":"Using different TextTensors","text":""},{"location":"guides/3/","title":"Chaining with TextModules","text":""},{"location":"guides/4/","title":"Advanced applications","text":""},{"location":"guides/text/","title":"1. Text Multiplication Guide","text":""},{"location":"guides/text/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"guides/text/#1-basics","title":"1. Basics:","text":""},{"location":"guides/text/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialized in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a special f-string-like sytnax which can parse most Text\u2019s from a single string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"guides/text/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"guides/text/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"guides/text/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"guides/text/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <pre><code> Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))\n</code></pre> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"guides/text/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"guides/text/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"guides/text/#4-additional-points","title":"4. Additional Points:","text":""},{"location":"guides/langchain_comparison/translation/","title":"Translation","text":"LangChain LangTorch PromptTemplate.from_template(prompt) TextTensor(prompt) ChatPromptTemplate.from_template([(role, message), ...]) RunnablePassthrough() TextModule(\"\") StrOutputParser # Not needed itemgetter(key)"},{"location":"reference/langtorch/","title":"Index","text":"<p>LangTorch implements many of the same utility functions one can use in Torch. Many of those operations are also automatically invoked even when using the equivalent function imported from torch. Here are these functions:</p>"},{"location":"reference/langtorch/#torch-functions","title":"Torch functions","text":""},{"location":"reference/tensors/texttensor/","title":"TextTensor","text":"<p>A <code>TextTensor</code> is a multi-dimensional matrix containing elements of structured text data, each represented as a <code>Text</code> object  of structured text.</p>"},{"location":"reference/tensors/texttensor/#initializing-and-basic-operations","title":"Initializing and Basic Operations","text":"<p>A <code>TextTensor</code> can be constructed from Python lists or sequences of string-like inputs. Every entry is transformed into a Text object, so each entry must satisfy one of its many possible input formats, which can include:</p> <ul> <li>Strings</li> <li>Tuples of the form  representing text keys and values</li> <li>Dictionaries of correctly ordered keys and values</li> <li>Sequences of any of the above</li> </ul>"},{"location":"reference/tensors/texttensor/#construction","title":"Construction","text":"<p>You can construct a <code>TextTensor</code>, similar to <code>torch.tensor</code>, where the input sequence can be shapes into  nested lists or a numpy array:</p> <pre><code>from langtorch import TextTensor\n\n# 0-d TextTensor\n\n# 1-d TextTensor\n\n# 2-d TextTensor, and so on\nTextTensor([[\"Hello, world!\"], [\"How are you?\"]])\n\n# With complex text entries\n\n\n# Text\n\nTextTensor([{\"greeting\": \"Hello\", \"name\": \"Alice\"}])\n</code></pre> <p>TextTensors can be created with familiar operations: <pre><code># A tensor of empty strings\nlangtorch.zeros(shape)\nlangtorch.zeros_like(tensor)\n\n# A tensor with all \n</code></pre></p> <p>Note</p> <p>TextTensors almost never get initialised from torch Tensors</p>"},{"location":"reference/tensors/texttensor/#indexing-and-slicing","title":"Indexing and Slicing","text":"<p>Access and modify the contents of a <code>TextTensor</code> using Python's indexing and slicing notation:</p> <pre><code>tt = TextTensor([[\"Hello\", \"World\"], [\"LangTorch\", \"Framework\"]])\nprint(tt[0][1])  # Outputs: \"World\"\ntt[1][0] = \"Welcome to\"\nprint(tt)  # Outputs: TextTensor([[\"Hello\", \"World\"], [\"Welcome to\", \"Framework\"]])\n</code></pre>"},{"location":"reference/tensors/texttensor/#item-extraction","title":"Item Extraction","text":"<p>Extract a single <code>Text</code> object from a <code>TextTensor</code>:</p> <pre><code>tt = TextTensor([[\"Hello\"]])\nsingle_text = tt.item()\nprint(single_text)  # Outputs: \"Hello\"\n</code></pre> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.set_key","title":"<code>set_key(keys=None, inplace=False)</code>","text":""},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.item","title":"<code>item()</code>","text":""},{"location":"reference/tensors/texttensor/#key-assignment","title":"Key Assignment","text":"<p>Explicitly assign or change keys in a <code>TextTensor</code> using the <code>set_key()</code> method:</p> <pre><code>tt = TextTensor([\"This is a sentence.\"])\ntt.set_key(\"sentence\")\n</code></pre> <p>For comprehensive details on creating and manipulating <code>TextTensors</code>, refer to the LangTorch documentation on <code>TextTensor</code> operations.</p> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.set_key","title":"<code>set_key(keys=None, inplace=False)</code>","text":""},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.item","title":"<code>item()</code>","text":""},{"location":"reference/tensors/texttensor/#warnings-and-notes","title":"Warnings and Notes","text":"<ul> <li>Operations involving keys require accurate matching between the template and data.</li> <li><code>TextTensors</code> support a variety of operations for modifying and generating new <code>TextTensors</code>.</li> <li>For advanced text processing with LLMs, utilize <code>TextModule</code> along with <code>TextTensors</code>.</li> </ul> <p>TextTensor is a specialized subclass of torch.Tensor designed for handling and manipulating textual data within the LangTorch framework. Each entry in a TextTensor is a structured Text object, enabling complex text operations and transformations, including natural language processing tasks and interaction with large language models (LLMs).</p> <p>TextTensor supports standard tensor operations adapted for text, such as concatenation and reshaping, alongside unique text-specific operations like prompt formatting through multiplication. It seamlessly integrates with PyTorch, allowing developers to leverage familiar tensor operations while working with textual data.</p> <p>Attributes:</p> Name Type Description <code>text_class</code> <code>Class</code> <p>Specifies the class used for entries in the TextTensor, typically set to the Text class.</p> <code>_embedding_module</code> <code>Union[str, TextModule]</code> <p>Module or name of an api model to convert TextTensor entries to embeddings.</p> <code>_tokenizer</code> <code>Tokenizer</code> <p>Tokenizer for converting TextTensor entries to tokens suitable for LLMs.</p> <code>parse</code> <code>bool</code> <p>Controls automatic parsing of text entries. Default is 'auto', which decides based on context.</p> Special Operations <ul> <li>Addition (<code>+</code>): Concatenates text entries.</li> <li>Multiplication (<code>*</code>): Formats prompt templates with values from another TextTensor or dictionary.</li> </ul> <p>Other Parameters:</p> Name Type Description <code>content</code> <code>(str, Text, list, dict)</code> <p>Initial content for the TextTensor. Can be a single string, a Text object, a list of strings or Text objects, or a dictionary for named entries.</p> <code>embedding</code> <code>Optional[Union[Tensor, List[float], ndarray, bool]]</code> <p>Optional embedding for the TextTensor. If True, computes embeddings for text entries automatically.</p> <code>metadata</code> <code>dict</code> <p>Additional metadata for the TextTensor.</p> <code>key</code> <code>str</code> <p>A key to associate with the TextTensor entries for structured operations.</p> <code>requires_grad</code> <code>bool</code> <p>Indicates whether the tensor should track gradients.</p> <code>is_gradient</code> <code>bool</code> <p>Marks the tensor as a gradient tensor.</p> <code>is_param</code> <code>bool</code> <p>Marks the tensor as a parameter tensor.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to the underlying torch.Tensor.</p> <p>Examples:</p> <p>Creating a TextTensor with prompt templates:</p> <pre><code>&gt;&gt;&gt; tt = TextTensor([\"Hello, {name}!\"])\n&gt;&gt;&gt; tt * TextTensor({\"name\": \"World\"})\nTextTensor([\"Hello, World!\"])\n</code></pre> <p>Concatenating TextTensors:</p> <pre><code>&gt;&gt;&gt; tt1 = TextTensor([\"Hello\"])\n&gt;&gt;&gt; tt2 = TextTensor([\", World!\"])\n&gt;&gt;&gt; tt1 + tt2\nTextTensor([\"Hello, World!\"])\n</code></pre> Note <ul> <li>Ensure proper key matching when performing operations that rely on named entries.</li> <li>Consider setting <code>requires_grad</code> appropriately for training LLMs or gradient-based operations.</li> </ul> Warning <ul> <li>Incorrect usage of keys or mismatched shapes during operations may lead to unexpected results.</li> </ul>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.split","title":"<code>split(sep, dim=0)</code>","text":"<p>Return a new TextTensor, with an additional first dimension to split everything using sep as the delimiter.</p> <p>sep     The delimiter according which to split the bytearray.     None (the default value) means split on ASCII whitespace characters     (space, tab, return, newline, formfeed, vertical tab).</p>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.apply","title":"<code>apply(func)</code>","text":"<p>Applies a function to each entry of self.content.</p>"},{"location":"reference/tensors/texttensor/#langtorch.tensors.TextTensor.backward","title":"<code>backward(tensors, grad_tensors=None, retain_graph=None, create_graph=False, grad_variables=None, inputs=None)</code>","text":"<p>See. docs</p>"},{"location":"reference/texts/text/","title":"Text","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#indexing","title":"Indexing","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre> <p>DESC</p> <p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> <ul> <li> <code>content</code>         \u2013          <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> </li> <li> <code>language</code>         \u2013          <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> </li> <li> <code>allowed_keys</code>         \u2013          <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> </li> </ul> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#langtorch.texts.Text.content","title":"<code>content</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.iloc","title":"<code>iloc</code>  <code>property</code>","text":"<p>Index-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Key-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.keys","title":"<code>keys()</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.values","title":"<code>values()</code>","text":""},{"location":"reference/texts/text/#langtorch.texts.Text.items","title":"<code>items()</code>","text":"<p>Retrieves key-value pairs from the Text object, allowing for structured data extraction and further processing.</p> <p>Returns:</p> <ul> <li> <code>List[Tuple[str, Union[str, Tuple[...]]]]</code>         \u2013          <p>A list of key-value pairs representing the Text's content.</p> </li> </ul>"},{"location":"reference/texts/text/#changing-keys","title":"Changing keys","text":"<p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre> <p>The Text class represents structured textual data within LangTorch, allowing for complex manipulations and operations on text similar to working with ordered dictionaries but with enhanced string manipulation capabilities.</p> <p>Attributes:</p> Name Type Description <code>content</code> <p>The core data of a Text instance, holding a sequence of \"named strings\" or key-value pairs. This attribute      allows Text to support operations like concatenation, formatting, and structured manipulation.</p> <code>language</code> <p>Specifies the language for parsing and formatting the textual content. Default is \"str\", but can be set       to other languages to support various textual operations and transformations.</p> <code>allowed_keys</code> <p>Optionally specifies a list of keys that are permitted within the Text instance. Attempts to use           keys not in this list will raise a ValueError, enforcing a schema on the textual data.</p> Initialization <p>Text instances can be initialized in multiple ways, including direct strings, tuples representing key-value pairs, dictionaries, or even from other Text instances. This flexibility allows developers to easily structure their textual data as needed for their applications.</p> Notes <ul> <li>Text instances support advanced text manipulation operations, including formatting via multiplication with other   Text instances or dictionaries, concatenation with other Text instances or strings, and even splitting into   TextTensor for further processing.</li> <li>The <code>iloc</code> and <code>loc</code> properties provide powerful mechanisms for accessing and manipulating sub-elements of a Text   instance based on index or key, respectively, facilitating easy modifications and queries.</li> </ul> <p>Examples:</p> <p>Initializing a Text instance:</p> <pre><code>&gt;&gt;&gt; text = Text(\"Hello, {name}!\", name=\"World\")\n&gt;&gt;&gt; print(text)\n\"Hello, World!\"\n</code></pre> <p>Concatenating Text instances:</p> <pre><code>&gt;&gt;&gt; greeting = Text(\"Hello\")\n&gt;&gt;&gt; target = Text(name=\"World\")\n&gt;&gt;&gt; combined = greeting + \", \" + target\n&gt;&gt;&gt; print(combined)\n\"Hello, World\"\n</code></pre> <p>Formatting Text instances:</p> <pre><code>&gt;&gt;&gt; template = Text(\"Dear {title} {last_name},\")\n&gt;&gt;&gt; formatted = template * {\"title\": \"Mr.\", \"last_name\": \"Doe\"}\n&gt;&gt;&gt; print(formatted)\n\"Dear Mr. Doe,\"\n</code></pre> <p>Accessing attributes:</p> <pre><code>&gt;&gt;&gt; text = Text(\"First\", \"Second\", key1=\"Value1\", key2=\"Value2\")\n&gt;&gt;&gt; print(text.keys())\n['key1', 'key2']\n&gt;&gt;&gt; print(text.items())\n[('key1', 'Value1'), ('key2', 'Value2')]\n&gt;&gt;&gt; print(text.iloc[0])\n\"First\"\n&gt;&gt;&gt; print(text.loc['key1'])\n\"Value1\"\n</code></pre>"},{"location":"reference/texts/text/#langtorch.texts.Text.set_key","title":"<code>set_key(key, inplace=False)</code>","text":"<p>Override keys for the textual entries, used for restructuring the content. Useful for substituting the key right before passing TextTensor to a Module.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key or keys to apply</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.add_key","title":"<code>add_key(key, inplace=False)</code>","text":"<p>Add a top-level  key, placing the items of the original as a value under the new key. Useful for working with nested keys like in Chat prompts.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key to add</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.iloc","title":"<code>iloc</code>  <code>property</code>","text":"<p>Index-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Key-based indexing. You can access entries with nested keys using dot notation, e.g. .loc[\"key1.key2\"]</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.__new__","title":"<code>__new__(*substrings, parse='langtorch-f-string', language='str', **named_substrings)</code>","text":"<p>Construct a new Text instance. Allows for various input formats.</p> <p>Parameters:</p> Name Type Description Default <code>*substrings</code> <code>Union[str,Tuple[str, str], List[str]</code> <p>Flexible input data. Can be a parsable string, string sequences, key-value pairs, dicts...                     If None is passed, it will be replaced with a Text instance with empty content.</p> <code>()</code> <code>parse</code> <code>Union[bool, str]</code> <p>Disable or specify a parsing langauge the input content is written.                         The default behavior is splits strings with an f-string-like syntax.                         You can pass a name of a markup language to parse it with pandoc.                         Set to False to disable parsing.</p> <code>'langtorch-f-string'</code> <code>language</code> <code>str</code> <p>The language that the content should be translated to when casting to string.</p> <code>'str'</code> <code>**named_substrings</code> <code>str</code> <p>Additional named textual data entries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Text</code> <p>A structured textual instance.</p> <p>Raises:</p> Type Description <code>ParseException</code> <p>If automatic parsing fails. Consider disabling parsing if this occurs.</p> <code>ValueError</code> <p>When an unsupported input format is provided e.g. a TextTensor is passed.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.add_key","title":"<code>add_key(key, inplace=False)</code>","text":"<p>Add a top-level  key, placing the items of the original as a value under the new key. Useful for working with nested keys like in Chat prompts.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key to add</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_api_responses","title":"<code>from_api_responses(*messages, **kwargs)</code>  <code>classmethod</code>","text":"<p>Text from a list of dicts of OpenAI style API responses</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_messages","title":"<code>from_messages(*messages, **kwargs)</code>  <code>classmethod</code>","text":"<p>Text from a list of dicts with keys 'role' and 'content'</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.from_pandoc_json","title":"<code>from_pandoc_json(ast_json)</code>  <code>classmethod</code>","text":"<p>Creates a Text object from a Pandoc AST JSON string.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.items","title":"<code>items()</code>","text":"<p>Retrieves key-value pairs from the Text object, allowing for structured data extraction and further processing.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, Union[str, Tuple[...]]]]</code> <p>A list of key-value pairs representing the Text's content.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.keyed_print","title":"<code>keyed_print()</code>","text":"<p>Prints the Text instance with keys aligned over their corresponding values.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.set_key","title":"<code>set_key(key, inplace=False)</code>","text":"<p>Override keys for the textual entries, used for restructuring the content. Useful for substituting the key right before passing TextTensor to a Module.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[Text, str, List[str]]</code> <p>The new key or keys to apply</p> required <code>inplace</code> <code>bool</code> <p>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Text</code> <p>A new Text instance with updated keys.</p>"},{"location":"reference/texts/text/#langtorch.texts.Text.str_formatter","title":"<code>str_formatter(instance, language='str')</code>  <code>classmethod</code>","text":"<p>Formats the human-readable string of a Text instance. Subclasses of Text can reimplement this method!</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Text</code> <p>An instance of the Text class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the instance.</p>"},{"location":"reference/tt/textmodule/","title":"TextModule","text":"<p>A <code>TextModule</code> is an abstraction designed to facilitate operations on <code>TextTensor</code> objects using a chain of texts transformations and language model inferences. It inherits from <code>torch.nn.Module</code>.</p> <p>Attributes:</p> Name Type Description <code>prompt</code> <code>TextTensor</code> <p>A <code>TextTensor</code> containing the prompt template(s) that will be                   used to format input texts data.</p> <code>activation</code> <code>Module</code> <p>A callable module, typically representing a language model                           inference call, which serves as the 'activation function' for                           the module. This activation function is applied to the                           formatted texts to obtain the output.</p> <code>key</code> <code>str</code> <p>An optional string representing the key that will be automatically assigned to        the output <code>TextTensor</code>.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>A <code>TextModule</code> may be created from a prompt template (str / TextTensor),                                              or a callable to create a nn.Module wrapper for it.                                               You can pass an activation (LLM) module,                                               and a key that should be added to entries of the output tensors.</p> <code>forward</code> <p>TextTensor) -&gt; TextTensor: Processes the input <code>TextTensor</code> by formatting it                                       with the module's content and then passing the                                       result through the activation function. The output                                       is then returned with the specified key.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; activation = Activation()  # This should be an instance of torch.nn.Module.\n&gt;&gt;&gt; text_module = TextModule(TextTensor([\"Summarize the following texts: {texts}\"]),\n                             activation=activation, key=\"summary\")\n&gt;&gt;&gt; input_text = TextTensor({\"texts\": \"An example input texts.\"})\n&gt;&gt;&gt; summary = text_module(input_text)\n# summary is a TextTensor with the key \"summary\" containing the summarized texts.\n</code></pre>"},{"location":"reference/tt/textmodule/#langtorch.TextModule.forward","title":"<code>forward(*input)</code>","text":"<p>By default, the TextModule forward formats the input using the prompt template tensors using TextTensor multiplication, then if not None applies an activation function, then if not None a key is set for all entries of the output TextTensor. Subclass this class to use forward hooks that check the input and output types and set the key.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>TextTensor</code> <p>The input <code>TextTensor</code> that needs to be processed.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>TextTensor</code> <code>TextTensor</code> <p>The output <code>TextTensor</code> with the content processed by the activation function         and assigned the specified key.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; input_text = TextTensor({\"texts\": \"An example input texts.\"})\n&gt;&gt;&gt; output = text_module(input_text)\n# output is a TextTensor with the processed content and key \"key_points\".\n</code></pre>"}]}