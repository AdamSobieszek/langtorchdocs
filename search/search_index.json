{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udd25Introducing LangTorch: A Paradigm Shift in LLM App Development","text":""},{"location":"#why-choose-langtorch","title":"Why Choose LangTorch?","text":"<p>While there are frameworks that focus on connecting large language models (LLMs) to various data sources, LangTorch offers something more than a wrapper for other services. LangTorch empowers developers to think of LLMs in the same intuitive way they perceive multidimensional arrays and neural network architectures. The result? Faster, more efficient, and intricate LLM application development. All core LangTorch components subclass their PyTorch counterparts, allowing developers to apply their existing skills to building novel LLM app architectures.</p>"},{"location":"#unique-features-of-langtorch","title":"Unique Features of LangTorch","text":"<ul> <li> <p>TextTensors as Datastuctures: Beyond just linking data, LangTorch's <code>TextTensor</code> unifies prompt templates, completion dictionaries, and chat histories under a single, powerful datastructure. Mimicking the functionalities of <code>torch.Tensor</code>, TextTensors hold arrays of structured Text data. Instead of magical methods to memorize, LangTorch defines simple rules for operations like addition and multiplication, enabling all kinds of text formatting and transformations, which lets developers think about what they want to build, instead of how the classes were named.</p> </li> <li> <p>TextModules as Building Blocks: LangTorch uses <code>TextModules</code>, a subclass of <code>torch.nn.Module</code>, that can perform all operations you may need in an LLM chain. As Modules operate on Tensors all operations are easily parallalizable and integrate seamlessly with PyTorch or Transformers Models and APIs. Building LLM apps with TextModules offers a similar experience to working with neural networks, but on a higher level of abstraction: Tree Summarization can be seen as a convolutional TextModule, Retrieval Augmented Generation as a Query-Key-Value Transformer-like Module.</p> </li> </ul>"},{"location":"#how-does-langtorch-stand-out","title":"\ud83e\uddef How Does LangTorch Stand Out?","text":"<ul> <li> <p>Intuitive Architecture: While other platforms might offer modular components or connectors, LangTorch's architecture is designed to mirror neural network paradigms. This makes transitioning from conventional AI development to LLM applications smooth and intuitive.</p> </li> <li> <p>Deep Integration: Instead of merely \"calling out\" to an LLM, LangTorch allows for deeper integration, making LLMs a true part of your application's architecture.</p> </li> <li> <p>Flexible and Scalable: From simple tasks to complex LLM chains, LangTorch scales seamlessly, accommodating both beginners and expert developers.</p> </li> </ul>"},{"location":"#dive-in-and-get-started","title":"Dive In and Get Started","text":"<p>LangTorch isn't just about advanced features; it's about making LLM application development accessible and enjoyable. Whether you're just starting out or are an experienced developer, LangTorch has tools and functionalities to meet your needs.</p> <p>Begin Your Journey: </p> <pre><code>pip install langtorch\n</code></pre> <p>Our documentation provides a Quick-Start Tutorial to help you craft your first application swiftly. Once you're familiar with the basics, delve deeper with Conceptual guides and our Documentation Reference. </p> <p>For hands-on examples, visit End-to-End Tutorials or compare End-to-End implementations in LangTorch vs LangChain Examples.</p> <p>Join us in revolutionizing the future of LLM application development. Welcome to the LangTorch era.</p>"},{"location":"guides/t/","title":"1. Text Multiplication Guide","text":""},{"location":"guides/t/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"guides/t/#1-basics","title":"1. Basics:","text":""},{"location":"guides/t/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialised in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a sepcial f-string-like sytnax which can parse most Text\u2019s from a signle string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"guides/t/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"guides/t/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"guides/t/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"guides/t/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <p><code>python  Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))</code></p> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"guides/t/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"guides/t/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"guides/t/#4-additional-points","title":"4. Additional Points:","text":"<ul> <li> <p>The <code>Text</code> class has a a special value <code>Text.identity</code>: an empty string with no key. This value is characterised by being it being the identity element of multiplication and  <code>Text.identity == 1</code> is defined to be true to make that connection, as:</p> <p><code>python some_text * 1 == some_text * Text.identity</code></p> </li> </ul>"},{"location":"reference/t/","title":"1. Text Multiplication Guide","text":""},{"location":"reference/t/#what-is-a-text","title":"What is a Text?","text":"<p>The basic object in LangTorch is <code>langtorch.TextTensor</code>, corresponding to <code>torch.nn.Tensor</code>. While <code>nn.Tensor</code> is a tensor of numbers, the <code>TextTensor</code> is a tensor of <code>Text</code> objects. Text objects are not simply strings to allow them to represent more complex objects and undergo more complex operations (e.g. multiplication, which will be a composition operation for Text objects that acts similar to the string .format method).  which are defined by a tuple <code>(content, key)</code> where content and key are regular strings.</p>"},{"location":"reference/t/#1-basics","title":"1. Basics:","text":""},{"location":"reference/t/#text","title":"Text:","text":"<ul> <li>Represents a sequence of \"named strings\". It acts as a regular string instance, but provides additional methods to manipulate the named strings within.</li> <li>The class provides multiple ways of creating instances, either through direct invocation or using patterns. That will be in the next chapter.</li> <li>The <code>Text</code> class can be initialised in multiple ways. This section focuses on constructing Text from strings, lists and dictionaries. A more convenient way is to use a sepcial f-string-like sytnax which can parse most Text\u2019s from a signle string. This is explained in the next chapter.</li> </ul> <pre><code># Creating a Text object with (key,  value) syntax:\ntext_obj = Text((\"greeting\", \"Hello\"), (\"object\", \"world\"))\nprompt = TextTensor([\"{object} says: {greating}\"}])\nprint(text_obj)  # Outputs: Helloworld\nprint(prompt*text_obj)  # Outputs: world says: Hello\n\n# Tho get substrings of the Text, the content attribute holds sub-Texts:\nprint(text_obj.content)  # Outputs: [Text((\"greeting\", \"Hello\")), Text((\"object\", \"world\"))]\n\n# Accessing the items (key-value pairs) of a Text object:\nitems = text_obj.items()\nprint(items)  # Outputs: [(\"greeting\", \"Hello\"), (\"object\", \"world\")]\n</code></pre>"},{"location":"reference/t/#2-operations-on-text","title":"2. Operations on Text:","text":""},{"location":"reference/t/#addition-operation","title":"Addition Operation:","text":"<p>The addition operation on <code>Text</code> and <code>TextTensors</code> simply concatenates them.</p> <pre><code># Concatenating two Text objects:\ntext1 = Text((\"greeting\", \"Hello\"))\ntext2 = Text((\"object\", \"world\"), \"!\")\nresult_text = text1 + text2\nprint(result_text)  # Outputs: Helloworld!\n\n# Mixing str2 and Text:\nmix_result = str1 + text2\nprint(mix_result)  # Outputs: Helloworld!\n</code></pre>"},{"location":"reference/t/#multiplication-operation","title":"Multiplication Operation:","text":"<p>The heart of this system is the multiplication operation, defined in the <code>__mul__</code> method of both classes. Here's how it works:</p>"},{"location":"reference/t/#single-key-text-multiplication","title":"Single-key Text Multiplication:","text":"<ul> <li> <p><code>str2 * str2</code>: When two Text objects are multiplied:</p> <ul> <li>If their keys match but not their contents, the contents get concatenated.</li> <li>If one is the inverse of the other (content and key swapped), the identity (an empty string) is returned.</li> <li> <p>If the content of the first <code>str2</code> matches the key of the second it acts as a format operation. For example:</p> <p><code>python  Text((\"\",\"key\")) * Text(\"key\",\"value\") == Text((\"\", \"value\"))</code></p> <p>You can interpret the whole operation like a multiplication of rational numbers:</p> <p>$$</p> <p>\\frac{\\text{'It works'}}{\\text{'a key'}}\\circ\\frac{\\text{ ' like this'}}{\\text{'a key'}} = \\frac{\\text{'It works like this'}}{\\text{'a key'}}\\ \\text{and}\\</p> <p>\\frac{\\text{'a phrase'}}{\\text{''}}\\circ\\frac{\\text{ 'text'}}{\\text{'a phrase'}} = \\frac{\\text{'text'}}{\\text{''}} $$</p> </li> <li> <p>For different keys, a new <code>Text</code> object is created with one <code>str2</code> instance after the other.</p> </li> <li><code>str2 * str</code>: If a <code>str2</code> object is multiplied with a regular string:</li> <li>If the <code>str2</code> doesn't have a key, the regular string is simply concatenated to its content.</li> <li>Otherwise, a new <code>Text</code> object is created with the <code>str2</code> followed by the regular string.</li> </ul> </li> </ul>"},{"location":"reference/t/#longer-text-multiplication","title":"Longer Text Multiplication:","text":"<ul> <li><code>Text * str2</code>: The str2 goes from left to right and if it finds a match for any of the rules above it applies it to that substring of Text, if none such match is found it appends itself to the Text</li> <li><code>Text * Text</code>: similar but for every in the right Text, it becomes clearer when we introduce creating Texts from strings</li> </ul>"},{"location":"reference/t/#inverse-operation","title":"Inverse Operation:","text":"<p>The inverse of a Text is obtained by swapping the key and content. To get the inverse of a Text you can either use the <code>inv()</code> method or the power operation <code>**-1</code>. The Text multiplied by its inverse is the empty string (<code>Text.identity</code>), as shown below.</p> <pre><code># For Text:\ntext_obj = Text((\"Hello\", \"greeting\"), (\"world\", \"object\"))\n# text_obj.inv() == text_obj**-1 == Text((\"greeting\", \"Hello\"), \n#                                                                                (\"object\", \"world\"))\n\n# We have:\n# text_obj*(text_obj**-1) == Text.identity == \"\"\n</code></pre>"},{"location":"reference/t/#4-additional-points","title":"4. Additional Points:","text":"<ul> <li> <p>The <code>Text</code> class has a a special value <code>Text.identity</code>: an empty string with no key. This value is characterised by being it being the identity element of multiplication and  <code>Text.identity == 1</code> is defined to be true to make that connection, as:</p> <p><code>python some_text * 1 == some_text * Text.identity</code></p> </li> </ul>"}]}